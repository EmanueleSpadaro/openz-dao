// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import './DAO.sol';
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

/**
 * @title DAOFactory is a contract following Factory Pattern to generate CcDAOs.
 */
contract DAOFactory {
    using EnumerableSet for EnumerableSet.AddressSet;
    string public name;
    string public realm;


    //Upgraded version, we can now have multiple DAOs inside the same place
    EnumerableSet.AddressSet daos;
    EnumerableSet.AddressSet factoryAdmins;
    mapping(string => EnumerableSet.AddressSet) placeDaos;
    mapping(address => EnumerableSet.AddressSet) userJoinedDaos;


    event DaoCreated(address indexed by);
    constructor(
        string memory _name, string memory _realm
    ){
        factoryAdmins.add(msg.sender);
        name = _name;
        realm = _realm;
        //todo do we really need AdminAdded event?
    }

    //todo do we really need a makeAdmin method even though we don't provide functions usable by admins (?)
    //todo do we really need admins at all for the given factory (?)

    function createDAO(
        string memory _firstlifePlaceID
    ) public {
        DAO newDao = new DAO(msg.sender, _firstlifePlaceID, address(this));
        daos.add(address(newDao));
        _addJoinedDao(newDao, msg.sender);
        emit DaoCreated(msg.sender);
    }

    function getPlaceDaos(string memory _firstlifePlaceID) public view returns(address[] memory) {
        return placeDaos[_firstlifePlaceID].values();
    }

    function getUserDaos(address _user) public view returns(address[] memory) {
        return userJoinedDaos[_user].values();
    }

    function addJoinedDaoTo(address _user) public {
        //The msg.sender shall be the DAO previously generated by the factory
        require(daos.contains(msg.sender) && address(DAO(msg.sender).daoFactory()) == address(this));
        _addJoinedDao(DAO(msg.sender), _user);
    }

    function _addJoinedDao(DAO daoContract, address user) internal {
        userJoinedDaos[user].add(address(daoContract));
    }

    function removeJoinedDaoTo(address _user) public {
        //The msg.sender shall be the DAO previously generated by the factory
        require(daos.contains(msg.sender) && address(DAO(msg.sender).daoFactory()) == address(this));
        userJoinedDaos[_user].remove(msg.sender);
    }
}
