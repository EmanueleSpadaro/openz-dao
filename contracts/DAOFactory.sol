// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import './DAO.sol';
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

/**
 * @title DAOFactory is a contract following Factory Pattern to generate CcDAOs.
 */
contract DAOFactory {
    using EnumerableSet for EnumerableSet.AddressSet;
    string public name;
    string public realm;


    //Upgraded version, we can now have multiple DAOs inside the same place
    EnumerableSet.AddressSet daos;
    mapping(string => EnumerableSet.AddressSet) placeDaos;
    mapping(address => EnumerableSet.AddressSet) userJoinedDaos;

    //The msg.sender shall be a DAO previously generated by the factory
    modifier isDao() {
        require(daos.contains(msg.sender) && address(DAO(msg.sender).daoFactory()) == address(this),
        "Caller must be a DAO registered by this factory");
        _;
    }

    //The msg.sender shall NOT be a DAO previously generated by the factory
    modifier isNotDao() {
        require(!daos.contains(msg.sender), "Caller must NOT be a DAO registered by this factory");
        _;
    }

    event DaoCreated(address indexed by, address daoAddress, string daoName, string firstlifePlaceID);

    constructor(
        string memory _name, string memory _realm
    ){
        name = _name;
        realm = _realm;
    }

    //Creates a DAO associated to the given firstlifePlaceID
    function createDAO(
        string memory _name,
        string memory firstlifePlaceID,
        string memory description_cid,
        address tokenFactory,
        address crowdsaleFactory,
        address exchangeFactory
    ) public isNotDao {
        address newDaoAddress = address(
            new DAO(msg.sender, _name, description_cid, firstlifePlaceID,
                tokenFactory, crowdsaleFactory, exchangeFactory, address(this))
        );
        daos.add(newDaoAddress);
        placeDaos[firstlifePlaceID].add(newDaoAddress);
        _addJoinedDao(newDaoAddress, msg.sender);
        emit DaoCreated(msg.sender, newDaoAddress, _name, firstlifePlaceID);
    }

    //Adds the msg.caller DAO to the user's joined DAOs
    function addJoinedDaoTo(address _user) public isDao {
        //The msg.sender shall be the DAO previously generated by the factory
        _addJoinedDao(msg.sender, _user);
    }

    //Adds the DAO to the user's joined DAOs UNSAFELY (doesn't check for the given dao to actually be one)
    function _addJoinedDao(address daoAddress, address user) internal {
        userJoinedDaos[user].add(daoAddress);
    }

    //Removes the caller DAO from the given user's joined DAOs
    function removeJoinedDaoFrom(address _user) public isDao {
        userJoinedDaos[_user].remove(msg.sender);
    }

    //It checks if the given address is effectively a DAO registered by the given DAOFactory
    function isDaoAddress(address addr) public view returns(bool) {
        return daos.contains(addr);
    }

    //Returns all the DAOs associated to the FirstLife place
    function getPlaceDaos(string memory firstlifePlaceID) public view returns(address[] memory) {
        return placeDaos[firstlifePlaceID].values();
    }

    //Returns all the DAOs joined by the given user
    function getUserDaos(address user) public view returns(address[] memory) {
        return userJoinedDaos[user].values();
    }
}
